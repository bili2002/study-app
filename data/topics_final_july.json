{
  "topics": [
    {
      "name": "1. Множества. Декартово произведение. Релации. Функции.",
      "questions": [
        {
          "q": "Аксиоматизация на множествата – аксиоми за обема, отделянето, степенното множество и индуктивно генерираните множества",
          "a": "• Обем – $A=B\\iff(\\forall x)(x\\in A\\leftrightarrow x\\in B)$.\n• Отделяне – $\\forall A\\,\\forall\\varphi\\,\\exists B\\,(\\forall x)(x\\in B\\iff(x\\in A\\land\\varphi(x)))$.\n• Степенно множество – $\\forall A\\,\\exists\\mathcal P(A)\\,(\\forall B)(B\\subseteq A\\Rightarrow B\\in\\mathcal P(A))$.\n• Индуктивно множество – $M=\\bigcup_{i\\in\\mathbb N}M_i$ with $M_0$ given and $M_{i+1}=M_i \\cup F(M_i)$ for some operator $F$."
        },
        {
          "q": "Математическа индукция",
          "a": "• Принцип на математическата индукция – ако $P(n_0)$ е вярно и $(\\forall k\\ge n_0)(P(k)\\Rightarrow P(k+1))$, то $(\\forall n\\ge n_0)\\,P(n)$.\n• Вариция - силна индукция."
        },
        {
          "q": "Основни операции върху множества и техните свойства",
          "a": "• Обединение – $A\\cup B=\\{x\\mid x\\in A\\lor x\\in B\\}$.\n• Сечение – $A\\cap B=\\{x\\mid x\\in A\\land x\\in B\\}$.\n• Разлика – $A\\setminus B=\\{x\\mid x\\in A\\land x\\notin B\\}$.\n• Допълнение – $\\overline{A}=U\\setminus A$.\n• Симетрична разлика – $A\\triangle B=(A\\setminus B)\\cup(B\\setminus A)$.\n• Степенно множество – $\\mathcal P(A)=\\{B\\mid B\\subseteq A\\}$.\nСвойства:\n• Комутативност – $A\\cup B=B\\cup A$, $A\\cap B=B\\cap A$.\n• Асоциативност – $A\\cup(B\\cup C)=(A\\cup B)\\cup C$, $A\\cap(B\\cap C)=(A\\cap B)\\cap C$.\n• Дистрибутивност – $A\\cap(B\\cup C)=(A\\cap B)\\cup(A\\cap C)$, $A\\cup(B\\cap C)=(A\\cup B)\\cap(A\\cup C)$.\n• Идемпотентност – $A\\cup A=A$, $A\\cap A=A$.\n• Нулев/единичен елемент – $A\\cup\\varnothing=A$, $A\\cap\\varnothing=\\varnothing$, $A\\cup U=U$, $A\\cap U=A$.\n• Де Морган – $\\overline{A\\cup B}=\\overline{A}\\cap\\overline{B}$, $\\overline{A\\cap B}=\\overline{A}\\cup\\overline{B}$.\n• Симетрична разлика – комутативна, асоциативна, $A\\triangle A=\\varnothing$."
        },
        {
          "q": "Наредена двойка и наредена n-орка",
          "a": "• Наредена двойка – $(a,b)=\\{\\{a\\},\\{a,b\\}\\}$.\n• Равенство на наредени двойки – $(a,b)=(c,d)\\iff a=c \\land b=d$.\n• Наредена $n$-орка – $(a_1,\\dots,a_n)=((a_1,\\dots,a_{n-1}),a_n)$."
        },
        {
          "q": "Декартово произведение и обобщено Декартово произведение на множества",
          "a": "• Декартово произведение – $A\\times B = \\{(a,b) \\mid a\\in A\\land b\\in B\\}$.\n• Обобщено Декартово произведение – $\\prod_{i=1}^{n}A_i = \\{(a_1,\\dots,a_n) \\mid a_1\\in A_1\\land\\dots\\land a_n\\in A_n\\}$."
        },
        {
          "q": "Релация над n домейна",
          "a": "• Релация над $n$ домейна – $R\\subseteq A_1\\times\\cdots\\times A_n$."
        },
        {
          "q": "Свойства на бинарните релации",
          "a": "• Рефлексивност – $(\\forall a\\in A)(a\\,R\\,a)$.\n• Антирефлексивност – $(\\forall a\\in A)\\,\\neg(a\\,R\\,a)$.\n• Симетричност – $(\\forall a,b\\in A)(a\\,R\\,b \\Rightarrow b\\,R\\,a)$.\n• Антисиметричност – $(\\forall a,b\\in A)(a\\ne b \\Rightarrow ((a\\,R\\,b)\\,\\oplus\\,(b\\,R\\,a)))$.\n• Силна антисиметричност (асиметричност) – $(\\forall a,b\\in A)(a\\,R\\,b \\Rightarrow \\neg b\\,R\\,a)$.\n• Транзитивност – $(a\\,R\\,b \\land b\\,R\\,c) \\Rightarrow a\\,R\\,c$."
        },
        {
          "q": "Релации на еквивалентост и класове на еквивалентност",
          "a": "• Еквивалентна релация – $R$ върху $A$ е еквивалентна, ако е рефлексивна, симетрична и транзитивна.\n• Клас на еквивалентност – $[a]_R=\\{x\\in A\\mid a\\,R\\,x\\}$."
        },
        {
          "q": "Релации на частична наредба",
          "a": "• Частична наредба – релация $\\preceq$ върху множество $A$ е частична наредба, ако е: рефлексивна, антисиметрична и транзитивна. Пример – $(\\mathcal P(S),\\subseteq)$"
        },
        {
          "q": "Диаграми на Хассе",
          "a": "• Диаграма на Хассе – неориентиран граф, получен от ориентирания граф на частична наредба $(A,\\preceq)$ чрез: \n 1. премахване на примките $(a,a)$; \n 2. запазване само на покритията $(a,b)$, т.е. $a\\prec b$ и няма $c$ с $a\\prec c\\prec b$;\n 3. изчертаване на ръбовете така, че краят $b$ да е по-високо от началото $a$, като стрелките и посоките се подразбират (отдолу нагоре)."
        },
        {
          "q": "Релации на пълна наредба",
          "a": "• Пълна наредба – т.е. имаме рефлексивност, антисиметричност, транзитивност + тоталност. Пример - $(\\mathbb N,\\le)$."
        },
        {
          "q": "Минимален и максимален елемент в релация на частична наредба",
          "a": "• Минимален елемент – $m\\in A$ е минимален, ако $(\\forall x\\in A)(x\\preceq m \\Rightarrow x=m)$. \n• Най-малък елемент – $0_A$ е най-малък, ако $(\\forall x\\in A)(0_A\\preceq x)$. \n• Максимален елемент – $M\\in A$ е максимален, ако $(\\forall x\\in A)(M\\preceq x \\Rightarrow x=M)$. \n• Най-голям елемент – $1_A$ е най-голям, ако $(\\forall x\\in A)(x\\preceq 1_A)$."
        },
        {
          "q": "Влагане на частична наредба в пълна наредба – топологично сортиране",
          "a": "• Линейно разширение (влагане) – ако $R$ е частична наредба върху $A$ и $R'\\supseteq R$ е линейна наредба върху $A$, тогава $R'$ е влагане (топологично сортиране) на $R$."
        },
        {
          "q": "Частични и тотални функции",
          "a": "• Частична функция – $f\\subseteq A\\times B$ и $(a,b_1)\\in f\\land(a,b_2)\\in f\\;\\Rightarrow\\;b_1=b_2$.\n• Тотална функция – частична функция $f$ c допълнително $\\forall a\\in A\\,\\exists b\\in B\\,((a,b)\\in f)$."
        },
        {
          "q": "Инекции, биекции и сюрекции",
          "a": "• Инекция – $(\\forall a_1,a_2\\in A)(f(a_1)=f(a_2)\\Rightarrow a_1=a_2)$.\n• Сюрекция – $\\forall b\\in B\\,\\exists a\\in A\\;(f(a)=b)$.\n• Биекция – $f:A\\to B$ е биективна, ако е едновременно инективна и сюрективна."
        },
        {
          "q": "Дефиниция на крайно множество и на кардиналност на крайно множество",
          "a": "• Крайно множество – $A$ е крайно, ако съществува естествено число $n$ и биекция $f:A\\to\\{1,2,\\dots,n\\}$.\n• Кардиналност – за крайно $A$, ако $f:A\\to\\{1,\\dots,n\\}$ е биекция, задаваме $|A|=n$."
        },
        {
          "q": "Дефиниция на изброимо безкрайно множество",
          "a": "• Изброимо безкрайно множество – $A$ е изброимо безкрайно, ако съществува биекция $f:\\mathbb N \\to A$."
        },
        {
          "q": "Принцип на Дирихле",
          "a": "• Принцип на Дирихле – за крайни множества $X,Y$ и тотална функция $f:X\\to Y$, ако $|X|>|Y|$, съществуват $a,b\\in X$ с $a\\ne b$ и $f(a)=f(b)$."
        }
      ]
    },
    {
      "name": "2. Основни комбинаторни принципи и конфигурации. Рекурентни уравнения.",
      "questions": [
        {
          "q": "Формулировки на принципите на изброителната комбинаторика – принцип на Дирихле, принцип на биекцията, принцип на събирането, принцип на изваждането, принцип на умножението, принцип на делението, принцип за включване и изключване (с доказателство)",
          "a": "• Принцип на Дирихле – $f:X\\to Y$, $|X|>|Y|\\;\\Rightarrow\\;\\exists x_1\\neq x_2\\in X:\\,f(x_1)=f(x_2)$.\n• Принцип на биекцията – ако съществува биекция $f:A\\leftrightarrow B$, то $|A|=|B|$.\n• Принцип на събирането (разбиване) – ако $A=\\bigsqcup_{i=1}^{k}A_i$ е дис­койнтно разбиване, тогава $|A|=\\sum_{i=1}^{k}|A_i|$.\n• Принцип на изваждането – за универсум $U$: $|A|=|U|-|\\overline{A}|$, където $\\overline{A}=U\\setminus A$.\n• Принцип на умножението – за $k$ независими стъпки с възможности $n_1,\\dots,n_k$ броят е $n_1\\cdots n_k$; в частност $|A\\times B|=|A|\\cdot|B|$.\n• Принцип на делението – $A$ е раз­би­то на еквивалентни класове по $\\sim$ с една и съща кар­ди­нал­ност $k$, следователно броят на класовете е $m=|A|/k$.\n• Принцип за включване и изключване – $\\bigl|\\bigcup_{i=1}^{k}A_i\\bigr|=\\sum_{i}|A_i|-\\sum_{i<j}|A_i\\cap A_j|+\\dots+(-1)^{k+1}|A_1\\cap\\dots\\cap A_k|$. Доказателство: елемент, който попада в точно $m$ множества, се брои $\\sum_{j=1}^{m}(-1)^{j+1}\\binom{m}{j}=1$ (защото $(1-1)^m=0$)."
        },
        {
          "q": "Основните комбинаторни конфигурации: с или без наредба, с или без повтаряне (с доказателства)",
          "a": "• Наредба + без повтаряне – вариации без повторение: $P(n,k)=\\dfrac{n!}{(n-k)!}$.\n• Наредба + с повтаряне – вариации с повторение: $n^{k}$.\n• Без наредба + без повтаряне – комбинации: $\\binom{n}{k}$.\n  Доказателство (индукция по $n$ с разлагане по последния елемент):\n  База $n=k$ или $k=0$ – точно 1 подмножество.\n  Стъпка: всеки $k$‑подмножество на $\\{1,\\dots,n\\}$ или не съдържа $n$ ($\\binom{n-1}{k}$ начина) или го съдържа ($\\binom{n-1}{k-1}$ начина). Следователно $\\binom{n}{k}=\\binom{n-1}{k}+\\binom{n-1}{k-1}$.\n• Без наредба + с повтаряне – комбинации с повторение: $\\binom{n+k-1}{k}$.\n  Доказателство (звезди и прегради): разполагаме $k$ неразличими звезди и $n-1$ прегради в редица от $k+n-1$ позиции. "
        },
        {
          "q": "Биномни коефициенти и теорема на Нютон",
          "a": "• Дефиниция – $\\displaystyle\\binom{n}{k}=\\dfrac{n!}{k!(n-k)!}$ за $0\\le k\\le n$.\n• Свойства – симетрия $\\binom{n}{k}=\\binom{n}{n-k}$; рекурентност $\\binom{n}{k}=\\binom{n-1}{k}+\\binom{n-1}{k-1}$.\n• Теорема на Нютон – $(x+y)^n=\\sum_{k=0}^{n}\\binom{n}{k}x^{k}y^{n-k}$.\n  Доказателство с индукция по $n$."
        },
        {
          "q": "Доказателства на комбинаторни тъждества чрез комбинаторни разсъждения (принцип на двукратното броене)",
          "a": "• \\(\\sum_{k=0}^{n}\\binom{n}{k}=2^{n}\\)\n  Броим всички подмножества: по елементи (2^n) и по размер k.\n• \\(\\sum_{k=0}^{n}k\\binom{n}{k}=n2^{n-1}\\)\n  Броим двойки (A,a), a∈A: по размер на A и по избор на отличен елемент.\n"
        },
        {
          "q": "Алгоритъм за решаване на линейни рекурентни уравнения с константни коефициенти – хомогенни и нехомогенни",
          "a": "• Хомогенна рекурента от ред k\n  \\[a_{n}+c_{1}a_{n-1}+\\dots+c_{k}a_{n-k}=0,\\qquad c_{k}\\ne 0.\\]\n  1) Построй характеристичния полином\n     \\[P(\\lambda)=\\lambda^{k}+c_{1}\\lambda^{k-1}+\\dots+c_{k}.\\]\n  2) Нека корените на P са β₁, …, β_t (t≤k) и кратностите им са r₁, …, r_t, така че r₁+⋯+r_t=k.\n  3) Общото решение е\n     \\[a_{n}^{(h)}=\\sum_{i=1}^{t}\\sum_{j=0}^{r_{i}-1}A_{i,j}\\,n^{j}\\,β_{i}^{\\,n}.\\]\n     • Ако всички корени са прости (r_i=1), това се свива до  \n       \\[a_{n}^{(h)}=A_{1}β_{1}^{n}+\\dots+A_{k}β_{k}^{n}.\\]\n  4) За да се намерят константите A_{i,j}, замести n=0,1,…,k−1 в (h) и получи k линейни алгебрични уравнения с k неизвестни.\n\n• Нехомогенна рекурента със същия ред k\n  \\[a_{n}+c_{1}a_{n-1}+\\dots+c_{k}a_{n-k}=\\sum_{s=1}^{\\ell}p_{s}(n)\\,b_{s}^{\\,n}.\\]\n  Тук p_s(n) е полином степен d_s, а b₁,…,b_ℓ са две по две различни константи.\n  Алгоритъмът е следният:\n  1) Игнорирай дясната страна и намери мултимножеството X на корените на P, както в хомогенния случай.\n  2) Построй мултимножеството Y: за всяко b_s включи го с кратност d_s+1 (пример – ако p_s е квадратичен, d_s=2 → кратност 3).\n  3) Вземи обединението X∪Y (сумираш кратностите на съвпадащите числа). Така получаваш базовите показатели β и новите им кратности \\(\\bar r_β\\).\n  4) Запиши общото решение на пълната рекурента точно във формата\n     \\[a_{n}=\\sum_{β}(\\;A_{β,0}+A_{β,1}n+\\dots+A_{β,\\bar r_{β}-1}n^{\\bar r_{β}-1}\\;)β^{\\,n}.\\]\n     – Когато b_s вече е корен на P, факторът n^{\\bar r_{β}-1} осигурява правилния „повдигнат“ ansatz (това е класическото правило за резонанс).\n  5) Неизвестните константи са \\(k+\\ell\\) на брой. Имаме k дадени начални стойности; за още \\(\\ell\\) уравнения използвай (10) с n = −1, −2, …, −ℓ. Получената линейна система определя всички константи и така се получава точното решение.\n\n• Проверката в края е задължителна: заместено в рекурентата, намереното a_n трябва да дава 0 (за хомогенната) или съответната дясна страна (за нехомогенната)."

        }
      ]
    },
    {
      "name": "3. Графи. Дървета. Обхождания на графи.",
      "questions": [
        {
          "q": "Дефиниции за краен ориентиран (мулти)граф и краен неориентиран (мулти)граф",
          "a": "• Краен ориентиран граф (без мулти):\n  \\[G = (V, E), \\quad E \\subseteq V \\times V\\]\n• Краен ориентиран мултиграф:\n  \\[G = (V, E, f_0), \\quad V \\text{ — крайно множество от върхове}, \\quad E \\text{ — крайно множество от ребра}\\]  \\[f_0: E \\to V \\times V\\]\n• Краен неориентиран мултиграф:\n  \\[G = (V, E, f_0), \\quad f_0: E \\to \\{\\{u,v\\} \\mid u,v \\in V\\}\\]\n• Краен неориентиран граф (без мулти):\n  \\[G = (V, E), \\quad E \\subseteq \\{\\{u,v\\} \\mid u,v \\in V\\}\\]"
        },
        {
          "q": "Дефиниции за път (цикъл) в ориентиран и неориентиран мултиграф",
          "a": "• Ориентиран път:\n  Нека \\(G=(V,E,f_0)\\) е ориентиран мултиграф.\n  \\[p=(v_0,e_1,v_1,e_2,\\dots,e_t,v_t),\\qquad t\\ge 0\\]\n  където\n  \\[v_i\\in V,\\; e_j\\in E,\\; f_0(e_j)=(v_{j-1},v_j)\\;(1\\le j\\le t).\\]\n  Цикъл: \\(v_0=v_t\\) и \\(t\\ge 1\\).\n\n• Неориентиран път:\n  Нека \\(G=(V,E,f_0)\\) е неориентиран мултиграф.\n  \\[p=(v_0,e_1,v_1,e_2,\\dots,e_t,v_t),\\qquad t\\ge 0\\]\n  където\n  \\[v_i\\in V,\\; e_j\\in E,\\; f_0(e_j)=\\{v_{j-1},v_j\\}\\;(1\\le j\\le t).\\]\n  Цикъл: \\(v_0=v_t\\) и \\(t\\ge 1\\)."
        },
        {
          "q": "Свързаност и свързани компоненти на граф",
          "a": "• Свързани върхове:\n  \\[u \\sim_G v \\;\\Longleftrightarrow\\; \\exists \\text{ път } u\\rightsquigarrow v.\\]\n\n• Свързан граф:\n  \\[G \\text{ е свързан } \\Longleftrightarrow (\\forall u,v\\in V)\\; u \\sim_G v.\\]\n\n• Свързани компоненти:\n  Класовете на еквивалентност по \\(\\sim_G\\). Индуцираният подграф \\(G[C]\\) се нарича свързана компонента. Също са и максималните по включване подграфи."
        },
        {
          "q": "Дефиниция на дърво и кореново дърво",
          "a": "• Дърво: \\[T=(V,E),\\quad T\\text{ е свързан и ацикличен.}\\]\n• Кореново дърво: \\[(T,r),\\quad r\\in V\\;\\text{— фиксиран корен на }T.\\]"
        },
        {
          "q": "Доказателство, че всяко кореново дърво е дърво и |V|=|E|+1",
          "a": "• (i) Кореново дърво → дърво:\n  Кореновото дърво е двойка \\((T,r)\\) с \\(T\\) свързан и ацикличен ⇒ \\(T\\) е дърво.\n\n• (ii) Свойство \\(|V| = |E| + 1\\):\n  Доказваме по индукция по \\(n=|V|\\).\n  База \\(n=1\\): \\(|E|=0\\) ⇒ \\(1 = 0 + 1\\).\n  Стъпка \\(n→n+1\\):\n  В дърво има лист \\(v\\). Премахваме \\(v\\) и реброто му \\(e\\), получаваме дърво \\(T'=(V',E')\\) с \\(|V'|=n, |E'|=n-1\\).\n  Връщайки \\(v,e\\): \\(|V|=n+1, |E|=n\\) ⇒ \\(|V| = |E| + 1\\)."
        },
        {
          "q": "Покриващо дърво на граф",
          "a": "• Нека $G=(V,E)$.\\n• За всяко дърво $T=(V,E_T)$ с $E_T\\subseteq E$ е покриващо дърво."
        },
        {
          "q": "Обхождане на граф в ширина и дълбочина",
          "a": "BFS(G, s):\n  for v ∈ V:  color[v] ← white\n  color[s] ← gray\n  Q ← ⟨s⟩\n  while Q ≠ ∅:\n    u ← pop(Q)\n    for (u,v) ∈ E:\n      if color[v] = white:\n        color[v] ← gray\n        parent[v] ← u\n        push(Q, v)\n    color[u] ← black\nИнвариант: опашката съдържа само gray върхове по ненамаляваща дистанция.\nПолу-инвариант: dist[v] не намалява.\n\nDFS(G):\n  for v ∈ V:  color[v] ← white\n  for v ∈ V:\n    if color[v] = white:\n      DFS-Visit(v)\n\nDFS-Visit(u):\n  color[u] ← gray\n  for (u,v) ∈ E:\n    if color[v] = white:\n      parent[v] ← u\n      DFS-Visit(v)\n  color[u] ← black\nИнвариант: стекът от рекурсии е проста пътека (gray върхове); black са приключени.\nПолу-инвариант: discover/finish интервалите на потомците са вложени."
        },
        {
          "q": "Ойлерови обхождания на мултиграф",
          "a": "• Ойлеров път: \\[p=(v_0,e_1,v_1,\\dots,e_m,v_m),\\quad m=|E|-1,\\] съдържа всяко ребро от графа точно веднъж.\n\n• Ойлеров цикъл: Ойлеров път с \\(v_0=v_m\\)."
        },
        {
          "q": "Теореми за съществуване на Ойлеров цикъл (с доказателство) и Ойлеров път",
          "a": "• Ойлеров цикъл (неориентиран мултиграф):\n  \\[G \\text{ свързан } \\land (\\forall v)\\, \\deg(v)\\equiv0\\pmod2 \\;\\Longleftrightarrow\\; G \\text{ има Ойлеров цикъл}.\\]\n  Доказателство: ⇐ Хиерхолцер – четност гарантира сшиване на затворени пътеки; ⇒ всеки вход има изход ⇒ степента е четна.\n\n• Ойлеров път:\n  \\[G \\text{ свързан } \\land |\\{v\\mid \\deg(v)\\text{ нечетна}\\}|\\in\\{0,2\\} \\;\\Longleftrightarrow\\; G \\text{ има Ойлеров път}.\\]\n  Доказателство: ако 0 – цикъл; ако 2 – добави фиктивно ребро, получи цикъл, махни го ⇒ път. В обратната посока пътят дава точно 0 или 2 върха с нечетна степен.\n\n"
        }
      ]
    },
    {
      "name": "4. Kрайни автомати. Регулярни езици.",
      "questions": [
        {
          "q": "Детерминирани крайни автомати",
          "a": ""
        },
        {
          "q": "Недетерминирани крайни автомати",
          "a": ""
        },
        {
          "q": "Представяне на всеки недетерминиран краен автомат с детерминиран (с доказателство)",
          "a": ""
        },
        {
          "q": "Регулярни операции",
          "a": ""
        },
        {
          "q": "Доказателство за затвореност на автоматните езици относно регулярните операции",
          "a": ""
        },
        {
          "q": "Регулярни езици",
          "a": ""
        },
        {
          "q": "Формулировка и доказателство на теоремата на Клини",
          "a": ""
        },
        {
          "q": "Формулировка и доказателство на лемата разрастване за регулярни езици (uvw-лема)",
          "a": ""
        },
        {
          "q": "Примери за нерегулярни езици",
          "a": ""
        },
        {
          "q": "Формулировка и доказателство на теоремата на Майхил -Нероуд",
          "a": ""
        },
        {
          "q": "Алгоритъм за конструиране на минимален краен детерминиран тотален автомат, еквивалентен на даден детерминиран краен автомат",
          "a": ""
        }
      ]
    },
    {
      "name": "5. Контекстносвободни граматики и езици. Стекови автомати.",
      "questions": [
        {
          "q": "Контекстносвободнa граматикa, дърво на синтактичен анализ, контекстносвободен език",
          "a": ""
        },
        {
          "q": "Доказателство на теоремите за затвореност на контекстносвободните езици",
          "a": ""
        },
        {
          "q": "Недетерминиран стеков автомат",
          "a": ""
        },
        {
          "q": "Изпълнение в недетерминиран стеков автомат",
          "a": ""
        },
        {
          "q": "Език, разпознаван от недетерминиран стеков автомат",
          "a": ""
        },
        {
          "q": "Доказателство на теорема за свеждане на контекстносвободна граматика към еквивалентен недетерминиран стеков автомат",
          "a": ""
        },
        {
          "q": "Формулировка и доказателство на лемата за разрастване за контекстносвободни езици",
          "a": ""
        },
        {
          "q": "Примери с доказателства за езици, които не са контекстносвободни",
          "a": ""
        },
        {
          "q": "Доказателство за незатвореността на контекстносвободните езици относно допълнение и сечение",
          "a": ""
        }
      ]
    },
    {
      "name": "6. Сложност на алгоритъм. Асимптотично поведение на целочислени функции. Сложност на рекурсивни програми.",
      "questions": [
        {
          "q": "Модели на изчисленията – машина на Тюринг, машина с произволен достъп и език за програмиране",
          "a": ""
        },
        {
          "q": "Дефиниции на (машинно-зависима) сложност (по време и памет) в най- лошия и средния случай",
          "a": ""
        },
        {
          "q": "Поведение на асимптотически положителни целочислени функции O / омега функции",
          "a": ""
        },
        {
          "q": "Свойства и гранични теореми (без доказателство)",
          "a": ""
        },
        {
          "q": "Формулировка на теоремата за решенията на рекурентни отношения от вида T(1)=(1), T(n)=a.T(n/b) + f(n), n>1",
          "a": ""
        }
      ]
    },
    {
      "name": "7. Алгоритми в графи с тегла на ребрата. Оценки за сложност.",
      "questions": [
        {
          "q": "Дефиниция на минимално покриващо дърво (МПД) на свързан граф с тегла на ребрата",
          "a": ""
        },
        {
          "q": "Формулировка и доказателство на теоремата за съгласуваното множество (условия за нарастване на подмножество на МПД)",
          "a": ""
        },
        {
          "q": "Алгоритми на Прим и Крускал, имплементации и оценка на сложността",
          "a": ""
        },
        {
          "q": "Задачи за най-къс път в граф с тегла на ребрата",
          "a": ""
        },
        {
          "q": "Дърво на най- късите пътища",
          "a": ""
        },
        {
          "q": "Алгоритъм за намиране на дърво на най-къси пътища в граф с константни тегла по ребрата и алгоритъм на Дейкстра",
          "a": ""
        },
        {
          "q": "Оценка на сложността",
          "a": ""
        },
        {
          "q": "Алгоритъм на Флойд за намиране на всички двойки най-кратки пътища",
          "a": ""
        }
      ]
    },
    {
      "name": "8. Динамично програмиране. Оценки за сложност.",
      "questions": [
        {
          "q": "Същност на алгоритмичната схема „динамично програмиране” – свеждане на задача със зададен размер към задачи от същия вид с по-малки размери и „мемоизация”",
          "a": ""
        },
        {
          "q": "Принцип за оптималност и конструиране на решението на задачата от решенията на подзадачите",
          "a": ""
        },
        {
          "q": "Задачи с линейна таблица на подзадачите (най-дълга растяща подредица)",
          "a": ""
        },
        {
          "q": "Задачи с триъгълна таблица на подзадачите (оптимално разбиване на редица)",
          "a": ""
        },
        {
          "q": "Задачи с правоъгълна таблица на подзадачите (най-дълга обща подредица на две редици, задача за раницата)",
          "a": ""
        }
      ]
    },
    {
      "name": "9. Компютърни архитектури – Формати на данните. Вътрешна структура на централен процесор – блокове и конвейерна обработка, инструкции.",
      "questions": [
        {
          "q": "Oбща структура на компютрите и концептуално изпълнение на инструкциите, запомнена програма",
          "a": "Съвременните компютри са изградени на базата на фон-Нойман архитектурата, при която програмният код и данните се съхраняват в една и съща физическа памет. Това позволява единна схема за достъп и обработка. Основните компоненти на типичен компютър включват централен процесор (CPU), оперативна памет (RAM), постоянна памет (ROM), кеш-памет от няколко нива и входно-изходни устройства.\n\nЦентралният процесор (CPU) е компонентът, който извършва основната обработка на информацията. Той взима инструкциите от паметта, интерпретира ги и ги изпълнява. CPU-то комуникира с останалите части чрез обща системна шина или вътрешни контролери. В него са вградени основни логически блокове като АЛУ, управляващо устройство и регистри (тези части се разглеждат по-подробно в отделен въпрос).\n\nОперативната памет (RAM) се използва за съхраняване на временни данни и инструкции, които се използват по време на изпълнение на програмата. RAM е бърза, но енергозависима – съдържанието ѝ се изтрива при изключване. ROM от своя страна съдържа непроменяеми инструкции, като например код за начално зареждане на системата (bootloader). Модерните компютри разполагат и с няколко нива кеш-памет – L1 (най-близо до CPU и най-бърза), L2 и L3. L1 често се разделя на две части – за инструкции и за данни. Тези кешове помагат да се избегне забавяне при достъп до основната памет.\n\nВходно-изходните устройства осигуряват комуникация между потребителя и системата – това включва клавиатура, дисплей, твърд диск, мрежови адаптери и др.\n\nИзпълнението на програмите става чрез така наречения instruction cycle (инструкционен цикъл), който се повтаря непрекъснато. Всяка инструкция преминава през три основни фази:\n\n1. Fetch – инструкцията се зарежда от паметта, като адресът ѝ се съдържа в специален регистър, наречен програмeн брояч (PC). След зареждането, PC се увеличава, освен ако не се извършва преход към друга инструкция.\n\n2. Decode – декодиране на инструкцията. Опкодът (обикновено няколко бита) указва каква операция да се извърши, а останалите битове съдържат допълнителна информация – адреси на регистри, константи или други параметри.\n\n3. Execute – операцията се изпълнява. Например, ако е аритметична операция, АЛУ извършва пресмятането и резултатът се записва в регистър или в паметта. Обикновено една операция се изпълнява в рамките на един машинен цикъл.\n\nЦелият този цикъл се повтаря за всяка следваща инструкция. Програмният брояч следи къде се намираме в програмата, и ако няма преход, автоматично сочи към следващата инструкция.\n\nКонцепцията за запомнена програма (stored program concept) е фундаментална за фон-Нойман архитектурата. Според нея, инструкциите на програмата не са „вградени“ хардуерно, а се съхраняват в паметта точно както и данните. Това дава гъвкавост – софтуерът може да се зарежда, модифицира и дори сам да се променя (например чрез компилатори, интерпретатори или програми, които генерират други програми). По този начин един компютър може да изпълнява всякакъв вид задачи, само чрез промяна на съдържанието в паметта – без нужда от хардуерни промени."
        },
        {
          "q": "Формати на даннитe – цели двоични числа, двоично-десетични числа, двоични числа с плаваща запетая, знакови данни и кодови таблици",
          "a": "Компютърът работи основно с двоични представяния на данни. В зависимост от контекста, числата и символите се кодират по различни начини:\n\nЦели двоични числа:\n- Без знак: записват се като поредица от \\( n \\) бита и покриват диапазона \\([0, 2^n - 1]\\).\n- Със знак: използва се допълнение до 2. Диапазонът е \\([-2^{n-1}, 2^{n-1} - 1]\\). Това позволява лесна работа с отрицателни числа без допълнителна логика.\n\nДвоично-десетични числа:\n- Всяка десетична цифра (0–9) се представя с 4 бита. Пример: 25 → \\(0010\\ 0101\\).\n- Използва се в системи, където се изисква точност на представянето (напр. калкулатори).\n\nПлаваща запетая:\n- Представят се във формата: \\( \\pm m \\cdot 2^e \\), където \\(m\\) е мантиса, а \\(e\\) е експонента.\n- Най-често се използва:\n  - Single precision: 32 бита (1 бит знак, 8 бита експонента, 23 бита мантиса).\n  - Double precision: 64 бита (1 + 11 + 52).\n- Поддържат се специални стойности: ±∞, NaN, денормализирани числа.\n\nЗнакови данни (символи):\n- Представят се чрез кодови таблици. Най-основният стандарт е ASCII – 7 бита за 128 символа (латиница, цифри, пунктуация).\n- Разширения на ASCII добавят допълнителни символи чрез 8-битов код (например CP1251 за кирилица).\n- Unicode (напр. UTF-8) позволява представяне на символи от всички езици. В UTF-8 символите са с променлива дължина (1–4 байта).\n\nКодови таблици:\n- Осигуряват съответствие между символ и неговия числов код. Примери: ASCII, ISO-8859-1, CP1251, Unicode.\n- Изборът на таблица определя кои символи могат да се използват и как се интерпретират числовите стойности."
        },
        {
          "q": "Централен процесор – регистри, АЛУ, регистри на състоянията и флаговете, блокове за управление, връзка с паметта, дешифрация на инструкциите, преходи.",
          "a": "- CPU е основният компонент, който извършва изчисления и контролира изпълнението на програми. Състои се от няколко ключови блока:\n\n• АЛУ (Аритметико-логическо устройство):\n- Изпълнява базови аритметични операции (+, –, *) и логически (AND, OR, XOR).\n- Обикновено една операция отнема 1 цикъл. Деление и по-сложни функции може да изискват повече.\n- При някои процесори има допълнителни единици за делене, тригонометрични функции и др.\n- Модерните CPU имат няколко АЛУ модула за паралелно изпълнение.\n\n• Управляващ блок (Control Unit – УУ):\n- Следи текущата инструкция (чрез програмния брояч – PC).\n- Декодира инструкциите и подава нужните сигнали към останалите блокове.\n- Координира достъпа до паметта, регистрите и ресурсите.\n\n• Регистри:\n- Вътрешна памет на CPU. Броят им варира (обикновено между 2 и 100+).\n- Използват се за съхраняване на временни стойности по време на изпълнение.\n- Някои регистри имат специални функции (напр. PC – програмен брояч, SP – стеков указател).\n\n• Флагове (регистър на състоянието):\n- Специални битове, които описват резултата от последната операция.\n- Примери: Z – zero, C – carry, S – sign, O – overflow и др.\n- Използват се при условни преходи и проверки.\n\n• Връзка с паметта:\n- CPU комуникира с RAM чрез инструкции за зареждане (load) и запис (store).\n- Адресирането и достъпът до паметта може да се оптимизират чрез кеш и предварително зареждане (prefetch).\n\n• Дешифрация на инструкциите:\n- Инструкцията съдържа opcode (вид операция) и операнди (регистри, адреси, стойности).\n- При CISC архитектури често се използва микро-код, докато при RISC – директна хардуерна логика.\n\n• Преходи (branch):\n- Инструкции, които променят стойността на PC.\n- Има условни и безусловни скокове. При условни се използват флагове.\n- Модерните CPU използват предсказване на преходи (branch prediction), за да избегнат забавяния при pipeline flush."
        }
      ]
    },
    {
      "name": "10. Структура и йерархия на паметта. Сегментна и странична преадресация. Система за прекъсване – приоритети и обслужване.",
      "questions": [
        {
          "q": "Структура на основната памет; Йерархия – кеш, основна и виртуална памет",
          "a": "В основата на компютърната памет стои единицата бит – стойност, която може да бъде 0 или 1. Всички данни и инструкции, които се съхраняват и обработват, са представени като поредици от битове. Осем последователни бита формират един байт. Всички байтове в паметта са подредени в последователни адресируеми клетки, всяка от които има уникален адрес – например адрес 0x0000, 0x0001 и т.н.\n\n Йерархия на паметта\nПаметта в компютърната система не е еднородна. Съществува йерархия, при която различните видове памет балансират между скорост, размер и цена. Колкото по-близо до процесора, толкова по-бърза и по-скъпа е дадената памет.\n\n1. Регистри: Това са най-бързите памети и се намират вътре в самия процесор. Достъпът до тях е почти моментален (за един такт). Обикновено броят им е малък – между 16 и 128, в зависимост от архитектурата.\n\n2. Кеш памет: Това е по-голяма, но все още изключително бърза памет, също разположена до или в самия процесор.\n- L1 кеш: много малък (16–64 KB), но изключително бърз (латентност ~1–2 цикъла). Обикновено разделен на две – за инструкции и за данни.\n- L2 кеш: по-голям (256 KB – 1 MB), малко по-бавен (~4–10 цикъла).\n- L3 кеш: споделен между ядрата (няколко MB – напр. 8–32 MB), с по-голяма латентност (~20–50 цикъла).\n\n3. Оперативна памет (RAM): Това е основната работна памет на компютъра, където се съхраняват текущо изпълнявани програми и техните данни. Изградена е с DRAM (Dynamic RAM), която е по-евтина и с по-висока плътност, но по-бавна от кеша. Достъпът до RAM може да отнеме над 100 цикъла.\n\n4. ROM (Read-Only Memory): Постоянна памет, която не се изтрива при изключване. Обикновено съдържа фърмуера на системата – напр. BIOS или bootloader. В съвременните системи ROM често е заменен от flash памет, която може да се пренаписва (например UEFI).\n\n5. Харддиск/SSD: Това е най-бавният тип памет, но с най-голям капацитет. Използва се за дългосрочно съхранение. Достъпът до харддиск е милиони пъти по-бавен от регистрите.\n\n SRAM срещу DRAM\n- SRAM (Static RAM): Използва се в кешовете. По-бърза и не се нуждае от опресняване, но заема повече място и е по-скъпа.\n- DRAM (Dynamic RAM): Използва се в основната памет (RAM). Необходим е постоянно refresh, но е евтина и плътна.\n\n Виртуална памет и MMU\nMMU (Memory Management Unit) е хардуерен блок, който преобразува логическите (виртуални) адреси, използвани от програмите, във физически адреси, които отговарят на реални позиции в паметта. Това позволява на всяка програма да работи в свой собствен адресен „свят“, без да се бърка с други процеси.\n\nВиртуалната памет комбинира RAM и част от харддиска (swap/page file), за да изглежда, че има повече памет, отколкото физически наличната. Когато RAM се запълни, по-малко използвани страници се прехвърлят на диска. Обратно, когато програмата се нуждае от тези страници отново, MMU ги зарежда обратно в RAM – процес, наречен „page fault“.\n\nТази йерархия позволява оптимален баланс между производителност и цена, като се използва бързата, но ограничена кеш и RAM, и по-бавната, но евтина памет на диска."
        },
        {
          "q": "Сегметна и странична преадресация – селектор, дескриптор, таблици и регистри при сегметна преадресация; каталог на страниците, описател, стратегии на подмяна на страниците при странична преадресация",
          "a": "Когато една програма използва памет, тя не работи директно с физически адреси. Вместо това, процесорът и операционната система използват логически (виртуални) адреси, които се преобразуват до физически чрез преадресация. Има два основни подхода – сегментна и странична преадресация.\n\nСегментна преадресация:\nПри сегментацията логическият адрес се състои от два компонента: селектор, който избира сегмент (например код, данни или стек), и отместване – позицията вътре в сегмента. MMU използва селектора, за да намери съответен дескриптор – структура, която съдържа началния адрес и размера на сегмента. След това физическият адрес се изчислява като: `физически адрес = базов адрес на сегмента + отместване`. Всеки сегмент може да има отделни права на достъп. Тази схема позволява логическо разделение на паметта, но се използва все по-рядко в съвременни системи, тъй като страда от фрагментация и е трудна за мащабиране.\n\nСтранична преадресация:\nПри страничната схема, паметта се разделя на малки фиксирани блокове – страници (например по 4 KB). Виртуалният адрес съдържа номер на страница и отместване в нея. MMU използва таблица на страниците, за да разбере къде точно в физическата памет се намира дадена виртуална страница. При по-големи таблици се използва многостепенна структура – например каталог на страниците, който сочи към други таблици. Така цялата памет е картографирана през страници и рамки.\n\nОписател на страница е запис в таблицата на страниците. Той съдържа адреса на физическата рамка, в която се намира съответната виртуална страница, както и допълнителни данни като права за достъп (четене/писане) и дали страницата е използвана или модифицирана. Така операционната система може да следи кои страници са активни и кои може да бъдат освободени.\n\nСтратегии за подмяна на страниците:\nКогато RAM се запълни и трябва да се зареди нова страница, се използва алгоритъм за избор коя стара страница да бъде премахната. Най-често използвани стратегии са:\n- FIFO (first-in, first-out): премахва най-старата страница, без значение дали е използвана наскоро.\n- LRU (least recently used): премахва страницата, която не е използвана от най-дълго време. Това дава по-добри резултати, но е по-сложно за реализация.\n- Clock (втора възможност): оптимизиран вариант на FIFO, при който всяка страница има бит за използване. Ако битът е активен, страницата получава втора възможност, иначе се премахва.\n\nТези механизми осигуряват ефективно използване на физическата памет и позволяват множество програми да работят едновременно, без да се пречат една на друга. Страничната преадресация е стандартният подход в съвременните операционни системи."
        },
        {
          "q": "Система за прекъсване – видове прекъсвания, структура и обработка, конкурентност и приоритети, контролери на прекъсванията",
          "a": "Прекъсването е механизъм, чрез който процесорът временно спира текущата инструкция, за да обслужи по-спешно събитие. Прекъсванията позволяват системата да реагира бързо на външни или вътрешни събития и са основа на мултитаскинга, реалновременната обработка и управление на хардуера.\n\nВидове прекъсвания:\n- Хардуерни – възникват при събития от външни устройства (например клавиатура, мишка, мрежа). Те са асинхронни спрямо програмата.\n- Софтуерни – предизвикани от самата програма, чрез инструкции като `INT`, за да се извика системен повик.\n- Изключения – генерират се автоматично при грешки като деление на нула, достъп до невалидна памет и др.\n\nСтруктура и обработка:\nКогато възникне прекъсване, процесорът автоматично запазва състоянието на текущата програма (най-често в стека), след което изпълнява специален обработващ код, наречен обработчик на прекъсване (interrupt handler). Той се намира на адрес, зададен в таблица с вектори (например IDT – Interrupt Descriptor Table). След изпълнение, процесорът се връща обратно към прекъснатия код.\n\nКонкурентност и приоритети:\nКогато две или повече прекъсвания възникнат едновременно, системата използва приоритети, за да определи реда на обслужване. Някои прекъсвания могат да бъдат маскирани (временно игнорирани), докато се обслужват други. Възможно е и вложено обслужване (nested interrupts), ако текущото прекъсване бъде прекъснато от по-високоприоритетно.\n\nКонтролери на прекъсванията:\n- PIC (Programmable Interrupt Controller): използва се в по-стари архитектури, управлява до 8 прекъсвания.\n- APIC (Advanced PIC): модерен контролер с поддръжка на много прекъсвания, приоритизиране и многопроцесорност.\n- IOAPIC: разширение за входно-изходни прекъсвания, особено важно при многопроцесорни системи.\n\nКонтролерите събират сигнали от различни устройства, задават приоритети и ги насочват към процесора. Съвременните ОС използват програмен и хардуерен контрол над прекъсванията, за да осигурят ефективност, реактивност и стабилност."
        }
      ]
    },
    {
      "name": "11. Файлова система. Логическа организация и физическо представяне.",
      "questions": [
        {
          "q": "Логическа организация на файлова система (ФС)",
          "a": ""
        },
        {
          "q": "Имена на файлове",
          "a": ""
        },
        {
          "q": "Типове файлове - обикновен файл, специален файл, каталог, символна връзка, програмен канал",
          "a": ""
        },
        {
          "q": "Вътрешна структура на файл",
          "a": ""
        },
        {
          "q": "Атрибути на файл",
          "a": ""
        },
        {
          "q": "Йерархична организация на ФС - абсолютно и относително пълно име на файл, текущ каталог",
          "a": ""
        },
        {
          "q": "Физическа организация на ФС",
          "a": ""
        },
        {
          "q": "Стратегии за управление на дисковото пространство",
          "a": ""
        },
        {
          "q": "Системни структури, съдържащи информация за разпределението на дисковата памет и съхранявани постоянно на диска: за свободните блокове; за блоковете, разпределени за всеки един файл; за общи параметри на ФС",
          "a": ""
        },
        {
          "q": "Примери за физическа организация на ФС: UNIX System V; LINUX; MS DOS; NTFS",
          "a": ""
        }
      ]
    },
    {
      "name": "12. Управление на процеси и междупроцесни комуникации.",
      "questions": [
        {
          "q": "Основни системни примитиви за управление на процеси",
          "a": ""
        },
        {
          "q": "Създаване на процес",
          "a": ""
        },
        {
          "q": "Изпълнение на програма",
          "a": ""
        },
        {
          "q": "Завършване на процес",
          "a": ""
        },
        {
          "q": "Синхронизация със завършването на процеса-син",
          "a": ""
        },
        {
          "q": "Права на процеси – потребителски идентификатори на процес",
          "a": ""
        },
        {
          "q": "Групи процеси и сесия",
          "a": ""
        },
        {
          "q": "Механизми за междупроцесни комуникации",
          "a": ""
        },
        {
          "q": "Сигнали",
          "a": ""
        },
        {
          "q": "Програмни канали",
          "a": ""
        },
        {
          "q": "IPC пакет на UNIX System V: Обща памет",
          "a": ""
        },
        {
          "q": "Семафори",
          "a": ""
        },
        {
          "q": "Съобщения",
          "a": ""
        }
      ]
    },
    {
      "name": "13. Компютърни мрежи и протоколи – OSI модел. Маршрутизация. Протоколи",
      "questions": [
        {
          "q": "IPv4, IPv6, TCP, DNS",
          "a": ""
        },
        {
          "q": "OSI модел – най-обща характеристика на нивата, съпоставяне с модела TCP/IP",
          "a": ""
        },
        {
          "q": "Разпределена маршрутизация – алгоритми с дистантен вектор и следене на състоянието на линията",
          "a": ""
        },
        {
          "q": "IPv4 адресация – класова и безкласова",
          "a": ""
        },
        {
          "q": "Основни характеристики на протокол IPv6",
          "a": ""
        },
        {
          "q": "TCP – процедура на трикратно договаряне",
          "a": ""
        },
        {
          "q": "Основни характеристики на протоколи DNS (резолвинг на имената по IPv4 и IPv6)",
          "a": ""
        }
      ]
    },
    {
      "name": "14. Процедурно програмиране – основни конструкции",
      "questions": [
        {
          "q": "Принципи на структурното програмиране",
          "a": "Структурното програмиране се основава на три контролни конструкции – последователност, разклонение (if/else) и цикъл (while, for). Кодът се организира в блокове {…} и функции, като се избягва \"goto\". Това прави програмите по-четими, по-лесни за поддръжка и проверка."
        },
        {
          "q": "Управление на изчислителния процес. Основни управляващи конструкции – условни оператори, оператори за цикъл",
          "a": "Условни оператори: if/else, switch, тернарен ?:. Цикли: for (init; cond; step), while (cond), do {…} while (cond). break спира най-вътрешния цикъл, continue пропуска остатъка от текущата итерация."
        },
        {
          "q": "Променливи – видове: локални променливи, глобални променливи; инициализация на променлива; оператор за присвояване",
          "a": "Локални променливи се декларират вътре в блок и съществуват до края му. Глобални се декларират извън функции и са достъпни навсякъде. Инициализация: int a=5; int b(6); int c{7}; Присвояване се извършва с =, като типовете трябва да са съвместими."
        },
        {
          "q": "Функции и процедури. Параметри – видове параметри. Предаване на параметри – по име и по стойност. Типове и проверка за съответствие на тип",
          "a": "Функция: <тип> <име>(параметри). Процедура = функция void. Параметри се предават по стойност (копие), по референция (int&), или чрез указател (int*). Компилаторът проверява типовете и броя аргументи при всяко извикване."
        }
      ]
    },
    {
      "name": "15. Процедурно програмиране – указатели, масиви и рекурсия.",
      "questions": [
        {
          "q": "Указатели и указателна аритметика",
          "a": ""
        },
        {
          "q": "Едномерни и многомерни масиви. Основни операции с масиви – индексиране. Сортиране и търсене в едномерен масив – основни алгоритми",
          "a": ""
        },
        {
          "q": "Символни низове. Представяне в паметта. Основни операции със символни",
          "a": ""
        },
        {
          "q": "Рекурсия – пряка и косвена рекурсия, линейна и разклонена рекурсия",
          "a": ""
        }
      ]
    },
    {
      "name": "16. Обектно-ориентирано програмиране. Основни принципи. Класове и обекти.",
      "questions": [
        {
          "q": "Наследяване и капсулация",
          "a": ""
        },
        {
          "q": "Абстракция със структури от данни",
          "a": ""
        },
        {
          "q": "Класове и обекти",
          "a": ""
        },
        {
          "q": "Декларация на клас и декларация на обект",
          "a": ""
        },
        {
          "q": "Основни видове конструктори",
          "a": ""
        },
        {
          "q": "Управление на динамичната памет и ресурсите (“RAII”)",
          "a": ""
        },
        {
          "q": "Методи – декларация, предаване на параметри, връщане на резултат",
          "a": ""
        },
        {
          "q": "Наследяване",
          "a": ""
        },
        {
          "q": "Производни и вложени класове",
          "a": ""
        },
        {
          "q": "Достъп до наследените компоненти",
          "a": ""
        },
        {
          "q": "Капсулация и скриване на информацията",
          "a": ""
        },
        {
          "q": "Статични полета и методи",
          "a": ""
        }
      ]
    },
    {
      "name": "17. Обектно-ориентирано програмиране. Подтипов и параметричен",
      "questions": [
        {
          "q": "полиморфизъм",
          "a": ""
        },
        {
          "q": "Множествено наследяване",
          "a": ""
        },
        {
          "q": "Виртуални функции и подтипов полиморфизъм",
          "a": ""
        },
        {
          "q": "Динамично свързване",
          "a": ""
        },
        {
          "q": "Абстрактни методи и класове",
          "a": ""
        },
        {
          "q": "Масиви от обекти и от указатели към обекти",
          "a": ""
        },
        {
          "q": "Параметричен полиморфизъм",
          "a": ""
        },
        {
          "q": "Шаблони на функция и на клас Множествено наследяване",
          "a": ""
        }
      ]
    },
    {
      "name": "18. Структури от данни. Стек, опашка, списък, дърво. Основни операции върху",
      "questions": [
        {
          "q": "тях",
          "a": ""
        },
        {
          "q": "Реализация Структури от данни – дефиниране на понятието",
          "a": ""
        },
        {
          "q": "Списък",
          "a": ""
        },
        {
          "q": "Логическо описание",
          "a": ""
        },
        {
          "q": "Списък с една и две връзки",
          "a": ""
        },
        {
          "q": "Характеристики на реализациите с една и две връзки",
          "a": ""
        },
        {
          "q": "Сложност на операциите по добавяне, премахване и намиране на елемент",
          "a": ""
        },
        {
          "q": "Дефиниране на клас за списък, използващ една от реализациите",
          "a": ""
        },
        {
          "q": "Стек",
          "a": ""
        },
        {
          "q": "Логическо описание",
          "a": ""
        },
        {
          "q": "Характеристики на статичната, динамичната и свързаната реализация",
          "a": ""
        },
        {
          "q": "Сложност на операциите по добавяне и премахване на елемент",
          "a": ""
        },
        {
          "q": "Дефиниране на клас за стек, използващ една от реализациите",
          "a": ""
        },
        {
          "q": "Опашка",
          "a": ""
        },
        {
          "q": "Логическо описание",
          "a": ""
        },
        {
          "q": "Характеристики на статичната, динамичната и свързаната реализация",
          "a": ""
        },
        {
          "q": "Сложност на операциите по добавяне и премахване на елемент",
          "a": ""
        },
        {
          "q": "Дефиниране на клас за опашка, използващ една от реализациите",
          "a": ""
        },
        {
          "q": "Дървовидни структури от данни – кореново дърво и двоично кореново дърво",
          "a": ""
        },
        {
          "q": "Логическо описание",
          "a": ""
        },
        {
          "q": "Начини за представяне в паметта",
          "a": ""
        },
        {
          "q": "Дефиниране на клас, реализиращ кореново дърво или двоично кореново дърво",
          "a": ""
        },
        {
          "q": "Двоично кореново дърво за търсене",
          "a": ""
        },
        {
          "q": "Логическо описание",
          "a": ""
        },
        {
          "q": "Начини за представяне в паметта",
          "a": ""
        },
        {
          "q": "Сложност на операциите по добавяне, премахване и търсене на елемент",
          "a": ""
        },
        {
          "q": "Дефиниране на клас реализиращ двоично кореново дърво за търсене",
          "a": ""
        }
      ]
    },
    {
      "name": "19. Функционално програмиране. Обща характеристика на функционалния стил",
      "questions": [
        {
          "q": "на програмиране",
          "a": ""
        },
        {
          "q": "Дефиниране и използване на функции",
          "a": ""
        },
        {
          "q": "Модели на оценяване",
          "a": ""
        },
        {
          "q": "Функции от по-висок ред",
          "a": ""
        },
        {
          "q": "Характерни особености на функционалния стил на програмиране",
          "a": ""
        },
        {
          "q": "Основни компоненти на функционалните програми",
          "a": ""
        },
        {
          "q": "Примитивни изрази",
          "a": ""
        },
        {
          "q": "Средства за комбиниране и абстракция",
          "a": ""
        },
        {
          "q": "Оценяване на израз",
          "a": ""
        },
        {
          "q": "Дефиниране на функция и оценяване на приложение на функция",
          "a": ""
        },
        {
          "q": "Модели на оценяване",
          "a": ""
        },
        {
          "q": "Апликативно (стриктно, call-by-value) и нормално (лениво, call-by-name) оценяване",
          "a": ""
        },
        {
          "q": "Функции от по-висок ред",
          "a": ""
        },
        {
          "q": "Функциите като параметри и оценки на обръщения към функции",
          "a": ""
        },
        {
          "q": "Анонимни (ламбда) функции",
          "a": ""
        },
        {
          "q": "Забележка: По този въпрос е възможно да бъдат дадени задачи за практическата част на изпита",
          "a": ""
        }
      ]
    },
    {
      "name": "20. Функционално програмиране. Списъци. Потоци и отложено оценяване.",
      "questions": [
        {
          "q": "Списъци",
          "a": ""
        },
        {
          "q": "Представяне",
          "a": ""
        },
        {
          "q": "Основни операции със списъци",
          "a": ""
        },
        {
          "q": "Функции от по-висок ред за работа със списъци",
          "a": ""
        },
        {
          "q": "Безкрайни потоци и безкрайни списъци",
          "a": ""
        },
        {
          "q": "Основни операции и функции от по- висок ред",
          "a": ""
        },
        {
          "q": "Отложено оценяване",
          "a": ""
        },
        {
          "q": "Работа с безкрайни потоци",
          "a": ""
        },
        {
          "q": "Забележка: По този въпрос е възможно да бъдат дадени задачи за практическата част на изпита",
          "a": ""
        }
      ]
    },
    {
      "name": "21. Синтаксис и семантика на термовете и формулите на предикатното смятане",
      "questions": [
        {
          "q": "от първи ред",
          "a": ""
        },
        {
          "q": "Унификация",
          "a": ""
        },
        {
          "q": "Дефинират се синтактичните понятия терм и формула от даден език на предикатното смятане",
          "a": ""
        },
        {
          "q": "Дефинират се понятията унификатор и най-общ унификатор за множество от термове",
          "a": ""
        },
        {
          "q": "Формулира се алгоритъм за намиране на най-общ унификатор за крайно множество от термове",
          "a": ""
        },
        {
          "q": "Дава се семантика на термовете и формулите в дадена структура за езика",
          "a": ""
        },
        {
          "q": "Доказва се, че множество от затворени универсални формули има модел точно тогава, когато множеството от частните му случаи е булево изпълнимо",
          "a": ""
        }
      ]
    },
    {
      "name": "22. Mетод на резолюцията в съждителното и в предикатното смятане от първи",
      "questions": [
        {
          "q": "ред",
          "a": ""
        },
        {
          "q": "Хорнови клаузи",
          "a": ""
        },
        {
          "q": "Дефинира се понятието съждителен резолютивен извод и се доказва теоремата за коректност и пълнота на резолютивната изводимост",
          "a": ""
        },
        {
          "q": "Описва се метода на резолюцията",
          "a": ""
        },
        {
          "q": "Дефинира се понятието хорнов дизюнкт и се доказва, че изпълнимите множества от хорнови дизюнкти имат най-малък модел",
          "a": ""
        },
        {
          "q": "Примерни типове задачи, свързани с въпроси 21 и 22: Практически задачи – за дефиниране на предикат с помощта на Пролог; за проследяване на изпълнението на програма на Пролог",
          "a": ""
        },
        {
          "q": "Теоретични задачи – за определимост и неопределимост на свойства в дадена структура; показване на изпълнимост на множество от предикатни формули чрез посочване на структура; доказване на неизпълнимост на множество от предикатни формули с помощта на метода на резолюцията",
          "a": ""
        }
      ]
    },
    {
      "name": "23. Бази от данни. Релационен модел на данните.",
      "questions": [
        {
          "q": "Релационен модел – основни понятия",
          "a": "Релационният модел представя данните под формата на таблици (релации), съставени от редове (кортежи) и колони (атрибути). Преди изграждане на релационна база, често се създава концептуален E/R модел, който после се трансформира към релационна схема."
        },
        {
          "q": "Домейн в релационния модел",
          "a": "Домейн е множеството от допустими стойности, които може да приеме даден атрибут. Например: домейнът на атрибута 'възраст' може да бъде цели числа между 0 и 120."
        },
        {
          "q": "Релация в релационния модел",
          "a": "Релацията е таблица от данни, съставена от кортежи (редове), всеки от които е дефиниран върху определен набор от атрибути (колони), свързани с домейни."
        },
        {
          "q": "Атрибути и кортежи",
          "a": "Атрибут е името на колона в релацията, свързано с конкретен домейн. Кортеж е един ред от таблицата – конкретна комбинация от стойности по атрибути."
        },
        {
          "q": "Схема на релация и схема на релационна база от данни",
          "a": "Схемата на релация описва името на релацията и списъка с атрибути. Пример: Човек(име, пол, дата_на_раждане, град). Схемата на релационна база от данни включва всички релации в базата като цяло."
        },
        {
          "q": "Реализация на релационна база от данни",
          "a": "Всяка таблица в релационна база се реализира като последователност от редове или колони, в зависимост от съответната система за управление (СУБД). При колонна организация стойностите от всяка колона се пазят отделно, което е полезно при анализи. За по-бързо търсене се използват индекси – най-често със структура B-дерево, което позволява ефективен достъп по ключови стойности."
        },
        {
          "q": "Видове операции върху релационна база от данни",
          "a": "Операциите върху релационна база от данни могат да се разделят според трите основни нива на представяне:\n\n1. Външно ниво (таблици) – операции за взаимодействие с потребителя: добавяне, редактиране, изтриване и извличане на данни.\n\n2. Концептуално ниво (множества) – логически операции от релационната алгебра като селекция, проекция, обединение, съединение и др.\n\n3. Вътрешно ниво (файлове) – операции за достъп до данните на ниско ниво: търсене, индексиране и управление на съхранението на диска.\n\nТази йерархия позволява ясна логическа структура и разделение между потребителския изглед, логическия модел и физическата реализация."
        },
        {
          "q": "Заявки към релационна база от данни",
          "a": "Заявките са команди, с които потребителят работи с данните в релационната база. Заявките позволяват извличане (SELECT), добавяне (INSERT), промяна (UPDATE) и изтриване (DELETE) на данни. Вътрешно, заявките се преобразуват в релационна алгебра и се изпълняват от СУБД чрез подходящи планове и индекси. Пример за заявка: SELECT име FROM Студент WHERE град = 'София';"
        },
        {
          "q": "Релационна алгебра – основни операции: обединение, разлика, декартово произведение, проекция, селекция",
          "a": "Релационната алгебра е формален език за работа с таблици (релации), при който входът и резултатът са релации. Основните операции включват:\n- Селекция (σ) – избира редовете, които отговарят на условие.\n- Проекция (π) – избира само определени атрибути (колони).\n- Обединение (∪) – комбинира всички редове от две таблици с еднакви атрибути.\n- Разлика (−) – връща редовете, които са само в първата релация.\n- Декартово произведение (×) – съчетава всеки ред от едната релация с всеки от другата.\nТези операции служат като основа за изграждане на заявки и обработка на данни в релационния модел."
        },
        {
          "q": "Релационна алгебра – допълнителни операции: сечение, частно, съединение, естествено съединение",
          "a": "Допълнителните операции в релационната алгебра разширяват основния набор:\n\n- Сечение (∩): връща редовете, които се срещат и в двете таблици с еднаква структура.\n\n- Частно (÷): използва се при търсене на обекти, които са свързани с всички стойности от друга таблица. Пример: студенти, взели всички предмети от списък.\n\n- Съединение (Join): комбинира редове от две таблици по зададено условие (например A.id = B.id). Това е θ-съединение.\n\n- Естествено съединение (⋈): специален вид съединение, при което се използват автоматично всички общи атрибути с еднакво име за сравнение. Излишните дублирани колони се премахват от резултата."
        }
      ]
    },
    {
      "name": "24. Бази от данни. Нормални форми.",
      "questions": [
        {
          "q": "Нормални форми в релационните бази от данни",
          "a": "Нормалната форма е правило или условие, което структурата на релационна таблица трябва да спазва, за да се избегнат аномалии при обновяване и излишно повторение на данни. Всяка нормална форма подобрява логическата организация на таблицата спрямо функционалните зависимости между атрибутите."
        },
        {
          "q": "Проектиране на схемите на релационни бази от данни",
          "a": ""
        },
        {
          "q": "Аномалии в релационния модел",
          "a": "Аномалиите са проблеми, които възникват при операции с данни, когато таблиците не са правилно нормализирани.\n\n- Излишества: една и съща информация се повтаря на много места, което води до излишна заетост и риск от противоречия.\n- Аномалия при обновяване: при промяна на стойност на едно място, тя трябва да се актуализира навсякъде; пропуски водят до несъгласуваност.\n- Аномалия при изтриване: изтриването на ред може да премахне и друга важна информация.\n- Аномалия при добавяне: понякога не можем да добавим информация, защото липсват други задължителни стойности според структурата на таблицата."
        },
        {
          "q": "Ограничения в релационния модел",
          "a": "Ограниченията определят правила, които данните в таблицата трябва да спазват, за да остане базата коректна. Те включват типове данни, уникалност, връзки между таблици и задължителни стойности."
        },
        {
          "q": "Ключове в релационния модел",
          "a": "Ключ е атрибут или комбинация от атрибути, които еднозначно идентифицират всеки ред в таблица. Суперключ е всеки набор от атрибути с това свойство. Ключ (или минимален суперключ) е такъв суперключ, при който не може да се премахне нито един атрибут, без да се загуби уникалността."
        },
        {
          "q": "Функционални зависимости и аксиоми на Армстронг",
          "a": "Функционална зависимост означава, че стойността на един атрибут (или група) определя еднозначно друга. Записва се като X → Y.\n\nАксиомите на Армстронг са:\n- Рефлексивност: ако Y е подмножество на X, тогава X → Y.\n- Добавяне (уголемяване): ако X → Y, тогава XZ → YZ за всяко Z.\n- Транзитивност: ако X → Y и Y → Z, тогава X → Z.\n\nТези правила се използват за извод на нови функционални зависимости и проверка на нормални форми."
        },
        {
          "q": "Първа нормална форма (1NF)",
          "a": "Таблица е в първа нормална форма (1NF), ако всяка колона съдържа само атомарни (неделими) стойности и няма повторящи се групи от данни."
        },
        {
          "q": "Втора нормална форма (2NF)",
          "a": "Таблица е във втора нормална форма (2NF), ако е в 1NF и всеки неключов атрибут зависи изцяло от целия първичен ключ, а не само от част от него."
        },
        {
          "q": "Трета нормална форма (3NF)",
          "a": "Таблица е в трета нормална форма (3NF), ако е в 2NF и всеки неключов атрибут зависи само от ключа, а не от друг неключов атрибут."
        },
        {
          "q": "Нормална форма на Бойс-Код (BCNF)",
          "a": "Таблица е в нормална форма на Бойс-Код (BCNF), ако за всяка функционална зависимост X → Y, X е суперключ. Това е по-строга форма на 3NF."
        },
        {
          "q": "Четвърта нормална форма (4NF)",
          "a": "Таблица е в четвърта нормална форма (4NF), ако е в BCNF и няма нетривиални многозначни зависимости, освен ако определящият атрибут е суперключ."
        },
        {
          "q": "Многозначни зависимости",
          "a": "Многозначна зависимост X ↠ Y означава, че за всяка стойност на X може да има множество независими стойности на Y, без това да влияе на другите атрибути."
        },
        {
          "q": "Аксиоми на функционалните и многозначните зависимости",
          "a": "Функционалните зависимости използват аксиомите на Армстронг: рефлексивност, добавяне и транзитивност. Многозначните зависимости имат подобни правила: X ↠ Y, ако Y е подмножество на X (рефлексивност); ако X ↠ Y и X ↠ Z, то X ↠ YZ (добавяне); транзитивност важи при определени условия."
        },
        {
          "q": "Съединение без загуба",
          "a": "Съединението е без загуба, ако след декомпозиция на таблица можем да възстановим оригиналната таблица чрез съединение, без загуба или добавяне на данни."
        }
      ]
    },
    {
      "name": "25. Търсене в пространството от състояния. Генетични алгоритми.",
      "questions": [
        {
          "q": "Пространство на състоянията",
          "a": ""
        },
        {
          "q": "Основни понятия",
          "a": ""
        },
        {
          "q": "Формулировка на основните типове задачи за търсене в пространството на състоянията: търсене на път до определена цел, формиране на стратегия при игри за двама играчи, намиране на цел при спазване на ограничителни условия",
          "a": ""
        },
        {
          "q": "Методи за информирано (евристично) търсене на път до определена цел: best-first search, beam search, hill climbing, A*",
          "a": ""
        },
        {
          "q": "Генетични алгоритми – основен алгоритъм, типове кръстосване и мутация",
          "a": ""
        }
      ]
    },
    {
      "name": "26. Съвременни софтуерни технологии.",
      "questions": [
        {
          "q": "Софтуерен продукт и процес",
          "a": ""
        },
        {
          "q": "Модел на софтуерен процес",
          "a": ""
        },
        {
          "q": "Софтуерни технологии",
          "a": ""
        },
        {
          "q": "Управление на софтуерен проект и ресурсите",
          "a": ""
        },
        {
          "q": "Участници в софтуерния процес",
          "a": ""
        },
        {
          "q": "Функционални и нефункционални изисквания",
          "a": ""
        },
        {
          "q": "Анализ и проектиране на софтуерните изсиквания",
          "a": ""
        },
        {
          "q": "Проектиране на софтуера",
          "a": ""
        },
        {
          "q": "Обектно-ориентиран дизайн",
          "a": ""
        },
        {
          "q": "Езици за описание",
          "a": ""
        },
        {
          "q": "UML",
          "a": ""
        },
        {
          "q": "Верификация и валидация на софтуера",
          "a": ""
        },
        {
          "q": "Тестване на софтуера",
          "a": ""
        },
        {
          "q": "Управление на процеса на тестване",
          "a": ""
        },
        {
          "q": "Управление на качеството на процеса на създаване на софтуер",
          "a": ""
        },
        {
          "q": "Съвременни софтуерни технологии",
          "a": ""
        },
        {
          "q": "Гъвкави (agile) софтуерни технологии",
          "a": ""
        },
        {
          "q": "Extreme Programming (XP)",
          "a": ""
        },
        {
          "q": "Test Driven Development",
          "a": ""
        },
        {
          "q": "Feature driven development",
          "a": ""
        },
        {
          "q": "SCRUM",
          "a": ""
        }
      ]
    },
    {
      "name": "27. Архитектури на софтуерни системи.",
      "questions": [
        {
          "q": "Софтуерни технологии центрирани около софтуерната архитектура",
          "a": ""
        },
        {
          "q": "Качествени атрибути – дизайн на архитектурата",
          "a": ""
        },
        {
          "q": "Дизайн за постигане на ефективност, сложност, скалируемост и хетерогенност, адаптируемост на архитектурата",
          "a": ""
        },
        {
          "q": "Надеждност и сигурност",
          "a": ""
        },
        {
          "q": "Компоненти и конектори",
          "a": ""
        },
        {
          "q": "Типове конектори и техните променливи характеристики",
          "a": ""
        },
        {
          "q": "Критерий за избор на подходящи конектори",
          "a": ""
        },
        {
          "q": "Архитектурни стилове",
          "a": ""
        },
        {
          "q": "Разпределени, мрежови, децентрализирани архитектури",
          "a": ""
        },
        {
          "q": "Архитектури, ориентирани към услуги и уеб услуги",
          "a": ""
        },
        {
          "q": "Клиент –сървър",
          "a": ""
        },
        {
          "q": "Анализ и визуализация на софтуерна архитектура",
          "a": ""
        }
      ]
    },
    {
      "name": "28. Симетрични оператори в крайномерни евклидови пространства. Основни",
      "questions": [
        {
          "q": "свойства",
          "a": ""
        },
        {
          "q": "Теорема за диагонализация",
          "a": ""
        },
        {
          "q": "Определение за симетричен оператор",
          "a": ""
        },
        {
          "q": "Матрица на симетричен оператор спрямо ортонормиран базис",
          "a": ""
        },
        {
          "q": "Всички характеристични корени на симетричен оператор са реални числа",
          "a": ""
        },
        {
          "q": "Всеки два собствени вектора, съответстващи на различни собствени стойности, са ортогонални помежду си",
          "a": ""
        },
        {
          "q": "Съществува ортонормиран базис на пространството, в който матрицата на симетричен оператор е диагонална",
          "a": ""
        }
      ]
    },
    {
      "name": "29. Симетрична и алтернативна група. Теорема на Кейли. Теорема за",
      "questions": [
        {
          "q": "хомоморфизмите на групи",
          "a": ""
        },
        {
          "q": "Симетрична група Sn – представяне на елементите като произведение на независими цикли",
          "a": ""
        },
        {
          "q": "Спрягане на елементите на Sn",
          "a": ""
        },
        {
          "q": "Транспозиции и представяне на елементите като произведение на транспозиции",
          "a": ""
        },
        {
          "q": "Алтернативна група",
          "a": ""
        },
        {
          "q": "Теорема на Кейли – всяка крайна група е изоморфна на подгрупа на симетричната група",
          "a": ""
        },
        {
          "q": "Хомоморфизъм при групи, ядро и образ",
          "a": ""
        },
        {
          "q": "Теорема за хомоморфизмите при групи",
          "a": ""
        }
      ]
    },
    {
      "name": "30. Теорема на Ферма. Теореми за средните стойности (Рол, Лагранж и Коши).",
      "questions": [
        {
          "q": "Формула на Тейлър",
          "a": ""
        },
        {
          "q": "Да се дефинира понятието локален екстремум на функция на една променлива",
          "a": ""
        },
        {
          "q": "Да се формулира и докаже необходимо условие за локален екстремум за диференцируеми функции (теорема на Ферма)",
          "a": ""
        },
        {
          "q": "Да се докажат следните теореми, формулирани общо за по-кратко",
          "a": ""
        },
        {
          "q": "Нека функцията е непрекъсната в затворения интервал и притежава производна поне в отворения интервал",
          "a": ""
        },
        {
          "q": "Да се докаже Рол",
          "a": ""
        },
        {
          "q": "Да се докаже Лагранж",
          "a": ""
        },
        {
          "q": "Да се докаже Коши",
          "a": ""
        },
        {
          "q": "По отношение на твърдението във в) да се докаже, че при направените в него предположения имам g(a) =/= g(b)",
          "a": ""
        },
        {
          "q": "Да се изведе формулата на Тейлър с остатъчен член във формата на Лагранж",
          "a": ""
        }
      ]
    },
    {
      "name": "31. Определен интеграл. Дефиниция и свойства. Интегруемост на непрекъснатите",
      "questions": [
        {
          "q": "функции",
          "a": ""
        },
        {
          "q": "Теорема на Нютон - Лайбниц",
          "a": ""
        },
        {
          "q": "Да се дефинират последователно: разбиване на интервал, големи и малки суми на Дарбу",
          "a": ""
        },
        {
          "q": "Да се установи, че при добавяне на нови точки в разбиването на интервала, големите суми на Дарбу не нарастват, а малките не намаляват (желателно е да се направи чертеж)",
          "a": ""
        },
        {
          "q": "Да се дефинира риманов интеграл чрез подхода на Дарбу",
          "a": ""
        },
        {
          "q": "Да се докаже, че дадена функция е интегруема по Риман тогава и само тогава, когато за всяко съществуват голяма сума на Дарбу S и малка сума на Дарбу s такива, че",
          "a": ""
        },
        {
          "q": "Като се използва тази теорема и теоремата на Кантор (без доказателство), според която всяка непрекъсната функция в краен и затворен интервал е равномерно непрекъсната, да се докаже, че всяка непрекъсната функция в краен и затворен интервал е интегруема по Риман",
          "a": ""
        },
        {
          "q": "Да се изброят (без доказателство) основните свойства на римановия интеграл",
          "a": ""
        },
        {
          "q": "За установяването на това твърдение да се приложат (без доказателство) свойството за интегриране на неравенства и теоремата, че всяка непрекъсната функция в [a, b] приема всички стойности между максимума и минимума си",
          "a": ""
        },
        {
          "q": "Да се докаже теоремата на Нютон-Лайбниц",
          "a": ""
        },
        {
          "q": "Да се покаже как теоремата се използва за изчисляване на определени интеграли",
          "a": ""
        }
      ]
    },
    {
      "name": "32. Уравнения на права и равнина. Формули за разстояния.",
      "questions": [
        {
          "q": "Векторни и параметрични (скаларни) уравнения на права и равнина",
          "a": ""
        },
        {
          "q": "Общо уравнение на права в равнината",
          "a": ""
        },
        {
          "q": "Декартово уравнение",
          "a": ""
        },
        {
          "q": "Взаимно положение на две прави",
          "a": ""
        },
        {
          "q": "Нормално уравнение на права",
          "a": ""
        },
        {
          "q": "Разстояние от точка до права",
          "a": ""
        },
        {
          "q": "Общо уравнение на равнина",
          "a": ""
        },
        {
          "q": "Взаимно положение на две равнини",
          "a": ""
        },
        {
          "q": "Нормално уравнение на равнина",
          "a": ""
        },
        {
          "q": "Разстояние от точка до равнина",
          "a": ""
        }
      ]
    },
    {
      "name": "33. Итерационни методи за решаване на нелинейни уравнения.",
      "questions": [
        {
          "q": "Да се дефинира понятието неподвижна точка на изображението  и да се докаже, че ако  е непрекъснато изображение на интервала [a,b] в себе си, то  има поне една неподвижна точка в [a,b]",
          "a": ""
        },
        {
          "q": "Да се покаже, че решаването на уравнението f(x) = 0 може да се сведе към намиране на неподвижна точка",
          "a": ""
        },
        {
          "q": "Да се дефинира понятието свиващо изображение и да се докаже, че ако  е непрекъснато изображение на интервала [a, b] в себе си и е свиващо с константа на Липшиц q<1, то: а) уравнението x = (x) има единствен корен  в [a,b]; б) редицата {xn} от последователни приближения (при произволно x0[a,b] и x n+1 = (xn), n = 0,1,2,…, клони към  при n → , като | xn – |  (b – a)qn, за всяко n",
          "a": ""
        },
        {
          "q": "Да се получи като следствие, че ако  е корен на уравнението x = (x) и  има непрекъсната производна в околностU на , за която( ) 1   , то при достатъчно добро начално приближение x0 итерационният процес, породен от , е сходящ със скоростта на геометрична прогресия",
          "a": ""
        },
        {
          "q": "Да се дефинира понятието ред на сходимост",
          "a": ""
        },
        {
          "q": "Да се дадат геометрична илюстрация, формула за последователните приближения и ред на сходимост при: метод на хордите, метод на секущите и метод на Нютон",
          "a": ""
        },
        {
          "q": "Да се докаже, че при метода на хордите сходимостта е със скоростта на геометричната прогресия (при условие, че коренът е отделен в достатъчно малък интервал)",
          "a": ""
        }
      ]
    },
    {
      "name": "34. Дискретни разпределения. Равномерно, биномно, геометрично и Поасоново",
      "questions": [
        {
          "q": "разпределение",
          "a": ""
        },
        {
          "q": "Задачи, в които възникват",
          "a": ""
        },
        {
          "q": "Моменти –математическо очакване и дисперсия",
          "a": ""
        },
        {
          "q": "На изпита комисията дава две разпределения, върху които се развива въпросът",
          "a": ""
        },
        {
          "q": "Дефиниция на дискретно вероятностно разпределение на случайна величина",
          "a": ""
        },
        {
          "q": "Свойства на вероятностите (неотрицателност и нормираност, монотонност и адитивност)",
          "a": ""
        },
        {
          "q": "За всяко от дадените две разпределения да се посочи пример, при който то възниква",
          "a": ""
        },
        {
          "q": "Да се пресметне математическото очакване и дисперсията на всяко от тези разпределения",
          "a": ""
        },
        {
          "q": "При пресмятанията може да се използва пораждаща функция или пораждаща моментите функция, но тя трябва да се дефинира и да се покажат основните й свойства (без доказателство)",
          "a": ""
        }
      ]
    }
  ]
}